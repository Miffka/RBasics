#setwd(as.character("C:/Users/miffka/Documents/!DataMining/RAnalysis"))
setwd("/media/glycosylase/EC6A2F256A2EEBD0/Documents and Settings/miffka/Documents/!DataMining/RAnalysis2")

#    Концепция векторизации
# Вектор - самая базовая структура данных в R
# На векторах основаны более сложные структуры (матрица, список, фактор, датафрейм)

# Вектор - индексированный набор данных одного типа
# R не делает разлиция между скалярными и векторными величинами, т.е. скаляр - это вектор длины 1
# Индексация начинается с единицы (не с нуля!)
# Для создания вектора можно использовать функцию vector

# можно создать вектор так
x <- vector(length = 2)
x[1] <- 5
x[2] <- 8

# а можно так
x1 <- c(5, 8)
y <- c(x, 1, c(3,4), x, NA)

# а еще можно применять последовательность :
5:9
3:-1
# или функцию seq
seq(1, 2, by = 0.25) # задаем шаг
seq(3, 4, length.out = 5) # задаем количество элементов
seq(3, 4, len = 5) # у аргумента можно указать уникальный префикс!!!

# повторение векторов
rep(1:3, times = 3)
rep(1:3, each = 4)
rep(1:3, length.out = 5)

# необходимо вызывать функции только в англоязычной раскладке

# тип данных double
0.1 + 0.1 == 0.2
0.1 + 0.05 == 0.15
all.equal(0.1 + 0.05, 0.15)

# последовательность из всех третей и седьмых

u <- seq(0, 1, 1/3)
v <- seq(0, 1, 1/7)
c(u, v)
help.search("sort")
w <- sort(c(u,v))
unique(w) # удаляем повторяющиеся значения

#    Задача 3 - написать функцию, которая возвращает все дроби вида {i/m,} {j/n}

get_fractions <- function(m, n) {
  u <- seq(0, 1, 1/m)
  v <- seq(0, 1, 1/n)
  return(unique(sort(c(u, v), decreasing = TRUE)))
}
get_fractions(3, 7)


#    Типы векторов

# логический TRUE/FALSE
# целочисленный (integer)
# числа с плавающей точкой (numeric/double)
# комплексный (complex)
# строковой (character)
# байтовая последовательность (raw)

# функции typeof и is.*

a <- c("Дуб - дерево", "Роза - цветок", "Воробей - птица")
typeof(a)
is.logical(a)

# Приведение типов
# Естественное - logical > integer > double > character

b <- c(FALSE, 1.5)
typeof(b)
b <- c(5, b, "abc")
typeof(b)
str(b)

# Принудительное приведение типов as.*

as.numeric(b)
# строка превратилась в пропущенное значение NA
as.integer(b)
# число 1,5 потеряло дробную часть

# Длина вектора

length(b)
x <- c(1:100)
length(x) <- 4
# потерялись все значения после 4
length(x) <- 7
# новые элементы получили значение по умолчанию - NA

# Имена векторов

a <- c(uno = 1, dos = 2, "universal answer" = 42, 99)
names(a)
names(a) <- c("one", "two", "forty two", "ninety nine") #переименовываем вектор
names(a)
names(a) <- NULL #убираем имена
str(a)


#    Векторная арифметика

# арифметические операторы векторизованы (применяются поэлементно)
1:3 + c(-1, 0, 2)
c(TRUE, TRUE, TRUE) & c(0, 1, 999)
# неявным образом сработало приведение типов - 0 стал FALSE, остальные - TRUE

sqrt(1:4)
floor(seq(0, 3, by = 0.25))
sum(1:100) #возвращает вектор длины 1

#    Задача 6 - валидные имена

xXx_TerM1Nat0R_xXx <- c(1:100)
next <- c(1:100) # ошибка
2b.or.not.2b <- c(1:100) # ошибка
function <- c(1:100) # ошибка
.hidden <- c(1:100)
:smiley: <- c(1:100) # ошибка
super_long_name_in_fact_so_long_i_cannot_stop_typing_please_help <- c(1:100)
